from collections import deque

def test_sequence(p, moves):
    """Test what sequence is generated by the given moves"""
    dq = deque(p)
    result = []
    
    for move in moves:
        if move == 'L':
            result.append(dq.popleft())
        else:
            result.append(dq.pop())
    
    return result

def is_bad_sequence(seq):
    """Check if sequence contains 5 consecutive increasing or decreasing elements"""
    if len(seq) < 5:
        return False
    for i in range(len(seq) - 4):
        if all(seq[j] < seq[j+1] for j in range(i, i+4)):
            print(f"Found 5 increasing at positions {i}-{i+4}: {seq[i:i+5]}")
            return True
    for i in range(len(seq) - 4):
        if all(seq[j] > seq[j+1] for j in range(i, i+4)):
            print(f"Found 5 decreasing at positions {i}-{i+4}: {seq[i:i+5]}")
            return True
    return False

# Test cases
test_cases = [
    ([1, 2, 3, 4, 5, 6, 7], "LRLRLRL"),
    ([1, 3, 6, 8, 9, 7, 5, 4, 2], "LLRLRLLLL"),
    ([1, 2, 11, 3, 6, 4, 7, 8, 12, 5, 10, 9], "LRLLLRLLLLLL"),
    ([4, 1, 2, 5, 6, 3], "RRLRLR"),
    ([1, 2, 3, 5, 4], "LRLRR"),
    ([5, 1, 8, 6, 2, 7, 9, 4, 3], "RLLLRRLLL")
]

print("Testing current solution:")
for i, (p, moves) in enumerate(test_cases, 1):
    seq = test_sequence(p, moves)
    bad = is_bad_sequence(seq)
    print(f"Test {i}: {p}")
    print(f"Moves: {moves}")
    print(f"Result: {seq}")
    print(f"Is bad: {bad}")
    print()

# Edge case testing
print("\n" + "="*50)
print("EDGE CASE ANALYSIS:")
print("="*50)

# Edge case 1: Minimum size (n=5)
print("1. Minimum size (n=5):")
p_min = [1, 2, 3, 4, 5]
# Simulate the algorithm
dq = deque(p_min)
moves = []
for i in range(min(6, 5)):  # Will be range(5)
    left = dq[0]
    right = dq[-1]
    if i % 2 == 0:  # Even: take min
        if left < right:
            dq.popleft()
            moves.append('L')
        else:
            dq.pop()
            moves.append('R')
    else:  # Odd: take max
        if left > right:
            dq.popleft()
            moves.append('L')
        else:
            dq.pop()
            moves.append('R')
    print(f"  Step {i}: left={left}, right={right}, chose={'L' if moves[-1]=='L' else 'R'}")

seq_min = test_sequence(p_min, ''.join(moves))
print(f"Result: {seq_min}")
print(f"Is bad: {is_bad_sequence(seq_min)}")
print()

# Edge case 2: Already sorted array
print("2. Already sorted array:")
p_sorted = [1, 2, 3, 4, 5, 6, 7, 8]
dq = deque(p_sorted)
moves = []
for i in range(min(6, 8)):
    left = dq[0]
    right = dq[-1]
    if i % 2 == 0:
        if left < right:
            dq.popleft()
            moves.append('L')
        else:
            dq.pop()
            moves.append('R')
    else:
        if left > right:
            dq.popleft()
            moves.append('L')
        else:
            dq.pop()
            moves.append('R')
    print(f"  Step {i}: left={left}, right={right}, chose={'L' if moves[-1]=='L' else 'R'}")

while dq:
    dq.popleft()
    moves.append('L')

seq_sorted = test_sequence(p_sorted, ''.join(moves))
print(f"Result: {seq_sorted}")
print(f"Is bad: {is_bad_sequence(seq_sorted)}")
print()

# Edge case 3: Reverse sorted array
print("3. Reverse sorted array:")
p_reverse = [8, 7, 6, 5, 4, 3, 2, 1]
dq = deque(p_reverse)
moves = []
for i in range(min(6, 8)):
    left = dq[0]
    right = dq[-1]
    if i % 2 == 0:
        if left < right:
            dq.popleft()
            moves.append('L')
        else:
            dq.pop()
            moves.append('R')
    else:
        if left > right:
            dq.popleft()
            moves.append('L')
        else:
            dq.pop()
            moves.append('R')
    print(f"  Step {i}: left={left}, right={right}, chose={'L' if moves[-1]=='L' else 'R'}")

while dq:
    dq.popleft()
    moves.append('L')

seq_reverse = test_sequence(p_reverse, ''.join(moves))
print(f"Result: {seq_reverse}")
print(f"Is bad: {is_bad_sequence(seq_reverse)}")
